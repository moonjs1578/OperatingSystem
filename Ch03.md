# CH03

## Process
- 실행 중인 프로그램
- 프로그램 객체 : 하나의 프로그램으로 여러 개의 프로세스 만들 수 있음
    - 크롬 창 3개를 띄우면 프로그램이 3개인 프로세스가 실행되고 있는 것
- CPU에 할당되어 실행될 수 있는 실체
- 명령어 실행, 현재 상태, 관련 시스템 자월을 특징으로 하는 활동 단위 
- 프로세스 구성 요소

### Process Creation
- Spawned by exisiting process(기존에 존재하는 프로세스에 의해 생성됨)
    - 사용자 프로그램은 모듈성을 높이거나 병렬성을 활용하기 위해, 여러개의 프로셋 생성을 지시할 수 있다.
- Normal completion(정상 종료) 
    - 프로세스는 실행 완료를 알리기 위해 OS 서비스 호출 실행
- Bounds violation(경계 위반)
    - 권한이 없는 메모리에 접근하려고 시도
- **Arithmethic error** 
    - 숫자를 0으로 나눌 때
- **Invalid instuction** 
    - CPU가 알지 못하는 명령어일 때 프로그램 죽음
- **Parent termination** : 부모 프로세스 종료될때, 운영체제는 모든 자식 프로세스를 종료 시킬 수 있다. 

### Process Control Block(PCB)
- 운영체제 내에서 관리되는 프로세스 구조체
- 커널에서 하나의 포로세스를 관리하는데 필요한 정보 요소(구조체의 멤버)들 을 갖고 있음

### Trace of Process
- Dispachter : 다른 프로세서로 넘겨줌
- Scheduler(Kernel 내 함수 이름) : 우선순위가 가장 높은 프로세스

```
New → Ready ──(스케줄러)──▶ Running
                ▲            │
                │            ▼
              ◀─ Ready ◀─(I/O 완료)── Waiting(Blocked)
                                   │
                                   └─(프로세스 종료)→ Terminated
```

- New : 메인 메모리 빈 공간 확보(오래돈 프로세스 disk)
- Ready : CPU만 있으면 실행할 수 있는 상태
- Waiting(Blocked) : I/O 장치에서 대기 상태, 기다리던 데이터가 도착하면 ready 상태가 됨
- Exit : 메모리에서 프로그램 제거

- Running -> Blocked 가는 경우
    - I/O 함수 호출 
    - Scheduler()함수가 CPU를 다른 process에게 넘겨 줌
        - Sheduler()함수
            - ready 상태 process들 중 우선순위가 가장 높은 프로세스를 고르고, processor를 그 process에게 넘겨줌
            - 실행할 다른 프로세스가 없을 경우 processor 는 for(;;) 무한 루프를 돌면서 대기함
- Blocked -> Ready 상태로 전환
    - Interrupt
        - processor는 현재 실행 중인 process 실행을 보류(Running -> ready)

### Ready Queue or Blocked Queue?
- Queue
    - process 구조체들을 linked list로 관리
- Ready Queue
    - Ready 상태의 process 구조체들만 모아 둔 linkedlist로 구현된 큐
- Blocked Queue
    - 키보드, 디스크, 네트웤 대기큐등이 있음

### Process Structure
1. Kernel : 커널에서 사용하는 공간
2. Stack : 임시적인 데이터가 저장되는 곳
3. Heap : 동적으로 할당 받음
4. Data : 변수가 할당되는 곳
5. Text : 실제 실행되는 기계어 명령어 및 어셈블리 코드가 쌓이는 곳

### 프로세스 구성 요소
1. Text segment 
- CPU에 의해 실행되는 machine 명령어 코드들
- Read-only
2. Intialized data segment
- 프로그램에서 초기화된 변수들이 저장되는 곳
3. Uninitialized data segment
- 초기화되지 않은 변수들이 저장되는 곳
4. **Stack**
- 함수 호출시 return해야 할 주소, 매개변수, 지역변수 Stack에 저장한다.
- 시험문제 Stack에 저장되지 않는 것은?
5. Heap
- 동적으로 할당하는 메모리
- unintialized data 꼭대기와 stack 사이에 존재

### Process Control Block
- 프로그램 하나 당 프로세스 구조체 하나
- Process Structure
    - Process Identification
        - Process ID, parent process ID, user ID, group ID

    - Processor(CPU) State Information
        - 실행중인 프로세스가 일시 중지될 때, 프로세서의 data 백업 시켜놓는 장소
        - Program counter register(PC)
            - 다음 명령어의 주소를 저장
        - Programs status word(PSW) register
            - 현재 정보를 요약해서 담고 있는 레지스터
        - Stack Pointer Register(SP)
            - Stack의 top을 가리킴
    - Process Control Information
        - Process state
        - priority
        - Scheduling-realter information
        - event
        - Data Structuring : 다양한 연결 리스트를 가리키는 포인터
    
### Modes of execution
- User mode
    - 적은 권한을 가진 모드
    - 사용자 프로그램들 일반적으로 실행되는 모드
- System, control, kernel mode
    - 많은 권한을 가진 모드
    - 커널 이 모드에서 실행
    - kernel mode로 변경되는 두 가지 이유
        - API 함수를 호출하여 커널로 진입할 때
        - CPU가 user mode실행하다가 interrupt가 들어와 드라이버 내 
        interrupt handler를 실행할 때

### Process Creation
- assign a unique process indetifier
- allocate space for the process
- initialize process control block
- set up appropriate linkages
- create or expand other data structure(I/O)

### 인터럽트 발생 시의 처리 과정
- Mode switch(user -> kernel)
    - I/O device 또는 timer 에서 interrupt 발생
네, 요청하신 내용을 마크다운 형식으로 정리해 드릴게요.
    -인터럽트 핸들러 (Interrupt Service Routine: ISR) 함수 실행
        - **ISR** (**Device Driver** 함수)의 고유 기능 실행: 예를 들어,
            - Network device ISR은 `Ethernet → IP → TCP` 함수를 호출한 후
            - 해당 device의 **대기 큐(Wait Queue)**에서 데이터를 기다리던 프로세스를 찾음
            - 데이터를 전달하고 **blocked** 상태에서 **ready** 상태로 변환
            - **대기 큐**에서 프로세스 구조체를 제거하고 **ready 큐(Ready Queue)**로 옮김
    - Scheduler()함수 호출  : 모든 ISR의 마지막엔 이 함수 호출함

### Process Switch
#### 언제 process switch가 발생하는가?
1. Clock(timer) interrupt
2. I/O interrupt
3. I/O 함수 호출
4. Trap interrupt(에러 발생 시 해당 장치가 발생시킴)
    - Exit state로 전환하고 현 프로그램 종료시킴
5. Memory fault interrupt

#### 실행 중지된 프로세스의 재실행 위치는?
- Interrupt가 발생했을 때
    - 실행중이던 프로세스 read queue에 들어감
    - 재실행되면 마지막으로 실행했던 명령어의 그 다음 명령어부터 실행
